#!/usr/bin/env python

import argparse
import os
import textwrap
import traceback
import sys
import shutil
from subprocess import call
from copy import copy
from collections import OrderedDict
from ansible.utils.color import stringc
from ansible.utils.display import Display
from ansible import constants as C

# used by WebhostPathResolver; which should be moved to a system lib
from os import readlink
from os.path import basename
from os.path import realpath
from os.path import dirname
class WebhostPathResolver:
  '''
    Derive values using EBRC file naming conventions.
    (this needs to be refactored into a OS-level shared lib) 
  '''
  def __init__(self, path):
    self.path = path
    self.product = self.product()
    self.context = self.context()
    self.servername = self.servername()
  def product(self):
    return dirname(readlink(self.path))
  def context(self):
    return basename(readlink(self.path))
  def servername(self):
    return basename(self.path)

display = Display()

class ConiferCLI(object):
  def __init__(self):
    parser = argparse.ArgumentParser(
      description='EBRC Website Configuration Manager',
      usage='''
conifer <command> [<args>]

Available commands:
  install   Install Conifer into GUS_HOME.

  seed   Generate a seed file that can be used as
  the basis for a minimal user-specific vars file.

  configure   Generate and deploy configurations.
'''
    )

    self.command = None
    self.hostname = None
    self.webapp_ctx = None
    self.project_home = None
    self.gus_home = None
    self.conifer_home = None
    self.cohort = None
    self.project = None
    self.env = None
    self.site_vars = None
    self.conifer_site_vars_seed_dest = None
    self.user_conf_dest = None
    self.verbose = False
    self.debug = False

    self.default_site_vars = 'conifer_site_vars.yml'
    self.user_conf_src_fname = 'conifer_site_vars.yml'
    self.conifer_site_vars_seed_fname = 'conifer_site_vars.seed.yml'
    self.user_conf_dest_fname = 'conifer_site_vars.yml'
    self.www_path = '/var/www'

    self.status = {}

    parser.add_argument('command', help='Subcommand to run')

    # parse_args defaults to [1:] for args, but you need to
    # exclude the rest of the args too, or validation will fail
    args = parser.parse_args(sys.argv[1:2])
    self.command = args.command
    if not hasattr(self, self.command):
      print 'Unrecognized command'
      parser.print_help()
      exit(1)

  def run(self):
    # use dispatch pattern to invoke method with same name
    getattr(self, self.command)()

  def configure(self):
    self._parse_args()
    self._copy_site_vars()
    extra_vars = [
      '-e', 'gus_home=' + self.gus_home,
      '-e', 'cohort=' + self.cohort,
      '-e', 'project=' + self.project,
      '-e', 'site_vars=' + os.path.basename(self.site_vars),
      '-e', 'templates_config=' + self.cohort + '/templates.yml',
    ]
    if self.env is not None:
      extra_vars.extend([ '-e', 'env=' + self.env ])
    if self.hostname is not None:
      extra_vars.extend([
        '-e', 'hostname=' + self.hostname,
      ])
    if self.webapp_ctx is not None:
      extra_vars.extend([
        '-e', 'webapp_ctx=' + self.webapp_ctx,
      ])
    if os.path.isfile(self.conifer_home + '/' + self.cohort + '_playbook.yml'):
      playbook = self.conifer_home + '/' + self.cohort + '_playbook.yml'
    else:
      playbook = self.conifer_home + '/playbook.yml'
    if self.verbose: display.display('Using playbook ' + playbook, color=C.COLOR_VERBOSE)
    rslt = self._run_playbook(extra_vars, playbook)
    if rslt == 0:
      self.status = { 'msg': 'Configuration complete.', 'color': C.COLOR_OK }
    else:
      raise Exception('Was unable to complete the configuration.')

  def seed(self):
    self._parse_args()
    if self.conifer_site_vars_seed_dest is None:
      self.conifer_site_vars_seed_dest = os.path.expanduser('~') + '/' + self.conifer_site_vars_seed_fname
    extra_vars = [
      '-e', 'gus_home=' + self.gus_home,
      '-e', 'cohort=' + self.cohort,
      '-e', 'project=' + self.project,
      '-e', 'templates_config=' + self.cohort + '/templates.yml',
      '-e', 'conifer_site_vars_seed_dest=' + self.conifer_site_vars_seed_dest
    ]
    if self.env is not None:
      extra_vars.extend([ '-e', 'env=' + self.env ])
    if self.hostname is not None:
      extra_vars.extend([
        '-e', 'hostname=' + self.hostname,
      ])
    if self.webapp_ctx is not None:
      extra_vars.extend([
        '-e', 'webapp_ctx=' + self.webapp_ctx,
      ])
    playbook = self.conifer_home + '/mk_site_vars.playbook.yml'
    rslt = self._run_playbook(extra_vars, playbook)
    if rslt == 0:
      msg = "A configuration seed file was created at {}.".format(self.conifer_site_vars_seed_dest)
      msg += " Rename this file to {} and edit to supply the missing values.".format( self.user_conf_dest)
      msg += " Then run 'conifer configure {}' to complete the configuration process.".format(' '.join(sys.argv[2:]).strip())
      wrapped = textwrap.fill((msg), display.columns, replace_whitespace=False, drop_whitespace=True)
      self.status = { 'msg': wrapped, 'color': C.COLOR_CHANGED}
    else:
      raise Exception('Was unable to generate a seed file.')


  def install(self):
    self._parse_args()
    if not os.path.isdir(self.project_home):
      raise Exception("Can not install because project_home, '" + self.project_home + "', not found.")
    for dir in [ self.gus_home + '/lib', self.gus_home + '/bin' ]:
      if not os.path.isdir(dir):
        print("mkdir {}".format(dir))
        os.makedirs(dir)
    cmd = ['find', self.project_home, '-path', '*/lib/conifer',
      '-type', 'd', '-name', 'conifer', '-exec', 'rsync', '-a', '{}', 
      self.gus_home + '/lib/',  ';' ]
    if self.verbose: print(' '.join(cmd))
    print('Installing Conifer into ' + self.gus_home)
    cpcore = call(cmd)
    cmd = ['rsync', '-a', self.project_home + '/FgpUtil/Util/bin/conifer',
      self.gus_home + '/bin/' ]
    if self.verbose: print(' '.join(cmd))
    cpbin = call(cmd)
    cmd = ['chmod', '0755', self.gus_home + '/bin/conifer']
    chmodbin = call(cmd)
    if cpcore == 0 and cpbin == 0 and chmodbin == 0:
      self.status = { 'msg': 'Installation complete.', 'color': C.COLOR_OK }
    else:
      raise Exception('Was unable to complete installation.')

  def _parse_args(self):
    parser = argparse.ArgumentParser(
      description='Deploy configurations')
    parser.add_argument("hostname", nargs='?', help="hostname for the website to configure")
    parser.add_argument("--project_home", help="path to GUS source code")
    parser.add_argument("--gus_home", help="")
    parser.add_argument("--cohort", help="")
    parser.add_argument("--project", help="")
    parser.add_argument("--webapp_ctx", help="")
    parser.add_argument("--env", help="configuration environment; typically 'development' or 'production'")
    parser.add_argument("--site_vars", help="")
    parser.add_argument("--verbose", action='store_true', help="Show some process details.")
    parser.add_argument("--debug", action='store_true', help="Show stack traces and other processing details.")
    # now that we're inside a subcommand, ignore the first
    # two argvs, ie the command (conifer) and the subcommand (configure)
    args = parser.parse_args(sys.argv[2:])
    self.args = args
    self.__dict__.update(copy(args.__dict__))

    if self.hostname is not None:
     if self.verbose: print('will attempt to derive args from EBRC-style file conventions')
     self._derive_env(self.hostname)
    else:
     for arg in ['gus_home','cohort', 'project', 'site_vars']:
       if eval('self.' + arg) is None:
         parser.error('--' + arg + ' is required')
    self.conifer_home = self.gus_home + '/lib/conifer'

  def _run_playbook(self, extra_vars, playbook):
    shell_env = os.environ.copy()
    shell_env["ANSIBLE_CONFIG"] = self.conifer_home + '/conifer.cfg'
    cmd = ['ansible-playbook', '-i', 'localhost,']
    cmd.extend(extra_vars)
    cmd.extend([playbook])
    if self.verbose: cmd.extend(['-vvvvv'])
    print("ANSIBLE_CONFIG={} {}".format(
      shell_env["ANSIBLE_CONFIG"], ' '.join(cmd))
    )
    return call(cmd, env=shell_env)

  def _derive_env(self, hostname):
    """
      Use EuPathDB BRC file/path naming conventions to derive
      parameter values, unless explicitly set on CLI.
    """
    wpr = WebhostPathResolver(self.www_path + '/' + hostname)
    if (self.gus_home is None):
      self.gus_home = self.www_path + '/' + hostname + '/gus_home'
    if (self.project_home is None):
      self.project_home = self.www_path + '/' + hostname + '/project_home'
    cohort_map = OrderedDict([
      ('ClinEpiWebsite', 'ClinEpi'),
      ('OrthoMCLWebsite', 'OrthoMCL'),
      ('MicrobiomeWebsite', 'Microbiome'),
      ('ApiCommonWebsite', 'ApiCommon'),
      ('WDKTemplateSite', 'WDKTemplate'),
    ])

    for dir, cohort in cohort_map.iteritems():
      p = self.www_path + '/' + hostname + '/project_home/' + dir
      if self.verbose: print("Looking for '{}'".format(p))
      if os.path.isdir(p):
        if self.verbose: print("Found '{}'".format(p))
        self.cohort = cohort
        break
    if self.cohort is None:
      raise Exception('Was unable to determine the cohort to use.')
    if self.verbose: print("Selecting cohort: {}".format(self.cohort))
    if self.project is None:
      self.project = wpr.product
    if self.webapp_ctx is None:
      self.webapp_ctx = wpr.context
    if self.site_vars is None:
      self.site_vars = self.www_path + '/' + self.hostname + '/etc/' + self.user_conf_src_fname
    self.conifer_site_vars_seed_dest = self.www_path + '/' + hostname + '/etc/' + self.conifer_site_vars_seed_fname
    self.user_conf_dest = self.www_path + '/' + hostname + '/etc/' + self.user_conf_dest_fname

  def _copy_site_vars(self):
    '''
      copy the site_vars file provided by the user into the
      Conifer vars directory so it's in the same place as all
      the other vars files and is given a pre-determined name.
    '''
    if os.path.isfile(self.site_vars):
      src = self.site_vars
    else:
      raise Exception("Can not find site_vars file: '{}'".format(self.site_vars))

    dest = self.conifer_home + '/roles/conifer/vars/'
    print("copying {0} to {1}".format(src, dest))
    shutil.copy2(src, dest)

if __name__ == '__main__':
  try:
    g = ConiferCLI()
    banner_args = { 'msg': 'CONIFER {} RESULTS'.format(g.command.upper()), 'color': 'bright blue' }
    display.banner('CONIFER {}'.format(g.command.upper()), color='bright blue')
    g.run()
    display.banner(**banner_args)
    if 'msg' in g.status:
      display.display(**g.status)
  except(Exception, KeyboardInterrupt) as e:
    display.banner(**banner_args)
    display.error(e)
    if g.debug: traceback.print_exc()
    sys.exit(1)
  sys.exit(0)
