package org.gusdb.fgputil.functional;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.NoSuchElementException;

import org.gusdb.fgputil.functional.FunctionalInterfaces.Function;
import org.gusdb.fgputil.functional.FunctionalInterfaces.Predicate;

public class Functions {

  /**
   * Returns a copy (a new HashMap) of the input map with entries trimmed out whose keys do not pass the
   * passed predicate
   * 
   * @param inputMap a map
   * @param keyPred a filter function on the keys of the map
   * @return a copy of the input map with non-passing entries removed
   */
  public static <S,T> Map<S,T> pickKeys(Map<S,T> inputMap, Predicate<S> keyPred) {
    return pickKeys(inputMap, keyPred, new LinkedHashMap<S,T>());
  }

  /**
   * Adds any entries in the input map whose keys pass the predicate to the target map.  Performs the same
   * basic operation as the two-argument version but allows the caller to specify the target map
   * implementation (e.g. LinkedHashMap), or a non-empty target map if desired.
   * 
   * @param inputMap a map of values
   * @param keyPred a filter function on the keys of the map
   * @param target a map into which the unfiltered elements should be placed
   * @return the target map
   */
  public static <S,T> Map<S,T> pickKeys(Map<S,T> inputMap, Predicate<S> keyPred, Map<S,T> target) {
    for (Entry<S,T> entry : inputMap.entrySet()) {
      if (keyPred.test(entry.getKey())) {
        target.put(entry.getKey(), entry.getValue());
      }
    }
    return target;
  }

  /**
   * Returns a copy (a new HashMap) of the input map with entries t
   * rimmed out whose values do not pass the
   * passed predicate
   * 
   * @param inputMap a map
   * @param valuePred a filter function on the values of the map
   * @return a copy of the input map with non-passing entries removed
   */
  public static <S,T> Map<S,T> pickValues(Map<S,T> inputMap, Predicate<T> valuePred) {
    return pickValues(inputMap, valuePred, new HashMap<S,T>());
  }

  /**
   * Adds any entries in the input map whose values pass the predicate to the target map.  Performs the same
   * basic operation as the two-argument version but allows the caller to specify the target map
   * implementation (e.g. LinkedHashMap), or a non-empty target map if desired.
   * 
   * @param inputMap a map of values
   * @param valuePred a filter function on the values of the map
   * @param target a map into which the unfiltered elements should be placed
   * @return the target map
   */
  public static <S,T> Map<S,T> pickValues(Map<S,T> inputMap, Predicate<T> valuePred, Map<S,T> target) {
    for (Entry<S,T> entry : inputMap.entrySet()) {
      if (valuePred.test(entry.getValue())) {
        target.put(entry.getKey(), entry.getValue());
      }
    }
    return target;
  }

  /**
   * Converts an iterable of keys into a map from the key to a value generated by the passed function
   * 
   * @param keys input keys
   * @param function value generator
   * @return map from passed keys to generated values
   */
  public static <S,T> Map<S,T> mapKeys(Iterable<S> keys, Function<S,T> function) {
    Map<S,T> result = new LinkedHashMap<>();
    for (S key : keys) {
      result.put(key, function.apply(key));
    }
    return result;
  }

  /**
   * Maps the given iterable elements to a List containing mapped elements.  The passed
   * function is executed on each input element; its outputs are placed in a new list and returned.
   * 
   * @param inputs an iterable of input elements
   * @param function a function to be performed on each element
   * @return List of function outputs
   */
  public static <S,T> List<T> mapToList(Iterable<S> inputs, Function<S,T> function) {
    List<T> result = new ArrayList<>();
    for (S obj : inputs) {
      result.add(function.apply(obj));
    }
    return result;
  }

  /**
   * Using the iterable collection and the predicate function passed in, filters those
   * items that satisfy the predicate into a new list
   * 
   * @param inputs - iterable collection to filter
   * @param predicate - predicate function supplying the filter test
   * @return - new list of filtered items
   */
  public static <T> List<T> filter(Iterable<T> inputs, Predicate<T> predicate) {
    List<T> result = new ArrayList<>();
    for(T obj : inputs) {
      if(predicate.test(obj)) {
        result.add(obj);
      }  
    }
    return result;
  }

  /**
   * Using the iterable collection and the predicate function passed in, removes from the
   * given collection, those items that do not satisfy the predicate.
   * 
   * @param inputs - iterable collection to be modified
   * @param predicate - predicate function supplying the filter test
   */
  public static <T> void filterInPlace(Iterable<T> inputs, Predicate<T> predicate) {
    Iterator<T> iterator = inputs.iterator();
    while(iterator.hasNext()) {
      if(!predicate.test(iterator.next())) {
        iterator.remove();
      }
    }
  }

  /**
   * Converts an iterator of one type to an iterator of another, given a conversion function
   *
   * @param <T> type of original iterator
   * @param <S> type of new iterator
   * @param iterator original iterator
   * @param transformer function to apply to each element before returning in new iterator
   */
  public static <T,S> Iterator<S> transform(final Iterator<T> iterator, final Function<T,S> transformer) {
    return new Iterator<S>() {

      @Override
      public boolean hasNext() {
        return iterator.hasNext();
      }

      @Override
      public S next() {
        return transformer.apply(iterator.next());
      }

      @Override
      public void remove() {
        iterator.remove();
      }
    };
  }

  /**
   * Converts an iterator over a Collection of items to an iterator over all the items in all the collections.
   * The iterator will iterate over the items in the first collection, then the second, until all collections
   * are exhausted.  No null Collections are allowed in the passed iterator; a null value will result in a
   * NullPointerException.  However, null items inside the collections will be returned as is.
   * 
   * @param collectionIter interator over a set of collections
   * @return iterator over the items in the collections
   * @throws NullPointerException if the passed iterator or any of the collections it iterates over are null
   */
  public static <T> Iterator<T> flatten(final Iterator<Collection<T>> collectionIter) {
    // create and initialize wrapper
    final Wrapper<Iterator<T>> wrapper = new Wrapper<>();
    if (collectionIter.hasNext()) {
      wrapper.set(collectionIter.next().iterator());
    }
    return new Iterator<T>() {

      @Override
      public boolean hasNext() {
        if (wrapper.get() == null) {
          // means there were no more collections in collectionIter
          return false;
        }
        // iterator value in wrapper; try to determine if there are any more items
        while (true) {
          // if current collection has next another value the use it
          if (wrapper.get().hasNext()) {
            return true;
          }
          // no more items in current collection; if no more collections then no more items
          if (!collectionIter.hasNext()) {
            return false;
          }
          // no more items in current collection and there is another collection; move to it
          wrapper.set(collectionIter.next().iterator());
        }
      }

      @Override
      public T next() {
        if (!hasNext()) {
          throw new NoSuchElementException();
        }
        return wrapper.get().next();
      }

      @Override
      public void remove() {
        throw new UnsupportedOperationException("The remove() method is not supported by this iterator.");
      }
    };
  }

  /**
   * Returns a function that takes a key and returns the value in the passed map for that key
   * 
   * @param map any map
   * @return functional facade over the map's get method
   */
  public static <S,T> Function<S,T> toMapFunction(final Map<S,T> map) {
    return new Function<S,T>() {
      @Override public T apply(S key) {
        return map.get(key);
      }
    };
  }
}
